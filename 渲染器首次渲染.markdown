# 渲染器首次渲染流程
## 实现初始化component主流程

先看看，vue3中初始绑定html的写法

~~~html
 <!DOCTYPE html>
 <html lang="en">
   <head>
     <meta charset="UTF-8">
     <meta http-equiv="X-UA-Compatible" content="IE=edge">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <title>Document</title>
   </head>
   <body>
     <div id="app"></div>
     <!-- 避免使用打包工具打包，降低流程，便于调试，这里直接将逻辑放在render.js中，使用script标签进行引入 -->
     <script src="./process/render.js"></script>
   </body>
 </html>
~~~

html的内容如何与vue3中的逻辑代码进行绑定？依靠的是Vue项目工程main.js文件汇总

~~~js
import App from './App.vue'


// 处理vue中组件逻辑内容，再挂载到真实dom节点上
createApp(App).mount('#app')                                
~~~

先不关心`createApp`和`mount`函数的实现。createApp接受的参数`App`就是通常在vue项目工程主文件的`App.js`中，通常也是vue项目的主入口：

~~~vue
export default {
    setup() {
        return {}
    }
}

 <template>
  <div>
   	hello mini-vue!
  </div>
</template>
~~~

vue3提供`render`和`h函数`，用于编程式地创建组件虚拟DOM树的函数，解析和创建`vnode`节点。

本文中单文件组件不在template中写，这需要编译能力，而是直接在render函数中实现

~~~js
 // 第二种方式
export const App = {
  render() {
    return h("div", "hi, " + this.msg)
  },

  setup() {
    // composition api

    return {
      msg: 'mini-vue'
    }
  }
}
~~~

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20221202133657665.png" alt="image-20221202133657665" style="zoom: 200%;" />

### createApp

`createApp(App).mount("#app")`

在createApp中，接受App单文件组件内容（App.js），需要返回一个对象，这个对象有一个mount方法，会把单文件组件先转化为虚拟节点，后续所有逻辑也都基于虚拟节点处理，最后将其挂载到根节点上

~~~ts
export function createApp(rootComponent) {
  return {
    mount(rootContainer) {
      // 先把所有东西转化为虚拟节点vnode
      // 后续所有逻辑操作基于 vnode 处理

      const vnode = createVNode(rootComponent)

      render(vnode, rootContainer);
    }
  }
}
~~~

### createVNode

createVNode用于创建虚拟节点，`type`描述节点对象，`props`描述属性，`children`描述子节点

~~~ts
export function createVNode(type, props?, children?) { // ?表示可选参数
  const vnode = {
    type,
    props,
    children
  };

  return vnode
}
~~~

### render & patch

render函数为处理和渲染 vnode 的入口函数

patch函数为处理节点类型的中转站，此时只增加`component`的逻辑：

~~~ts
export function render(vnode, container) {

  // 调用patch方法（方便后续递归处理）
  patch(vnode, container)
}

 const patch = function(vnode, container) {
   // 调用processComponent函数，对component的vnode进行处理
   processComponent(vnode, container)
 }
~~~

### processComponent

继续调用mountCompount对组件解析

~~~js
 const processComponent = function(vnode, container) {
   mountComponent(vnode, container)
 }
~~~

### mountComponent

用于拆解组件，组件中有`setup()`和`render() {}`

所以`mountComponent`首先要执行`setup`，setup的返回值是dom中需要触发、渲染用到的数据。再对`render`函数中`h`函数返回的vnode进行处理和渲染

~~~ts
function mountComponent(vnode, container) {
  // 创建组件实例
  const instance = createComponentInstance(vnode);
  // 处理setup  
  setupComponent(instance)
  // 处理render
  setupRenderEffect(instance, container)
}
~~~

------ 分割线 下面为一系列的`componet`处理函数 ------

`component.ts`

#### createComponentInstance

createComponentInstance用于创建额包装一个component对象，挂载属性，便于后续处理

~~~js
function createComponentInstance(vnode) {
    const component = {
        vnode,
        type: vnode.type,
        // 用于保存setup函数执行结果
        setupState: {}
    }

	return component
}
~~~

#### setupComponent

继续调用setupStatefulComponent对setup函数处理

~~~ts
function setupComponent(instance) {
    setupStatefulComponent(instance)
}
~~~

#### setupStatefulComponent

调用setup函数，保存执行结果

~~~js
function setupStatefulComponent(instance) {
    // 如果使用component组件来初始化vnode，整个组件对象会保存在type中
    const component = instance.type
    const { setup } = component
    
    if (setup) {
        // 执行setup
        const setupResult = setup()
        // 调用handleSetupResult处理
        handleSetupResult(instance, setupResult)
    }
}
~~~

需要注意的是，关于在什么地方获取`setup`，如果使用`component`来初始化`vnode`，整个的组件对象会保存在`vnode`的`type`中，这一点是和`element`有区别的。可以看一下`createVNode`函数的实现和调用逻辑。

#### handleSetupResult

保存setup函数的执行结果，便于后续应用

~~~ts
function handleSetupResult(instance, setupResult) {
    if (typeof setupResult === 'object') {
        // 将执行结果设置到ocmponent的实例中
        instance.setupState = setupResult
    }
    // 取得vnode中的render函数，保存到component的实例中，相当于解构，少一层访问
    instance.render = instance.type.render
}
~~~

------ 分割线 `component`类型调用结束 ------

### setupRenderEffect

开始调用vnode中的render函数，处理vnode节点

~~~ts
 const setupRenderEffect = function(instance, container) {
   // 执行render函数
   const subTree = instance.render()
   // 由于执行render后返回依然是一个vnode对象，继续递归调用patch进行处理
   patch(subTree, container)
 }
~~~

## rollup打包库

+ `Rollup`是一个模块打包器，和`webpack`类似
+ `Rollup`支持`Tree-shaking`，开元静态分析代码中的`import`，排除不被使用的代码
  + `webpack`虽然也支持，但是需要我们手动配置
+ 打包的结果比`webpack`小
+ 打包框架/组件库使用`Rollup`更合适



安装rollup

~~~powershell
yarn add rollup --dev
~~~

创建rollup.config.js，配置

~~~js
import typescript from "@rollup/plugin-typescript";

export default {
  // 入口文件
  input: "./src/index.ts",
  // 出口文件
  output: [
    // 1.cjs -> comonjs
    // 2.esm -> es6模块规范（标准）
    {
      format: "cjs",
      file: "lib/guide-mini-vue.csj.js",
    },
    {
      format: "es",
      file: "lib/guide-mini-vue.esm.js",
    },
  ],
  /// 安装转译官方插件 ts-->js @rollup/plugin-typescript
  plugins: [typescript()],
};
~~~

在package.json中配置一下rollup命令

-c指定运行的文件

~~~json
"scripts": {
    "build": "rollup -c rollup.config.js"
}
~~~

同时还需要安装`@rollup/plugin-typescript`，`typescript`,`tslib`相关依赖



在runtime-core中需要导出createApp和h

~~~ts
// runtime-core/index.ts

export { createApp } from "./creatApp" 
export { h } from "./h"
~~~

在出口文件中把runtime-core中全部导出

~~~ts
// src/index.ts

export * from './runtime-core/index'
~~~

之前的流程已经处理，接下来写个hello world，创建exanple/helloworld

App.js

```js
import { h } from '../../lib/mini-vue.esm.js'
 
export const App = {
  render() {
    return h("div", "hi, " + this.msg)
  },

  setup() {
    // composition api

    return {
      msg: 'mini-vue'
    }
  }
}
```

index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mini-vue</title>
</head>
<body>
    <div id="app"></div>
    <script src="main.js" type="module"></script>
</body>
</html>
```

main.js

```js
import { createApp } from "../../lib/mini-vue.esm.js"
import { App } from "./App.js"

const rootContainer = document.querySelector("#app")
createApp(App).mount(rootContainer)
```

到此为止，最基本的框架搭建完成。

我们运行index.html，报错instance.render不是一个function

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20221204205102827.png" alt="image-20221204205102827" style="zoom:50%;" />

原因：

在main.js中，`creatApp(App).mount(rootContainer)`会调用`render`，再调用`patch`，调用其他函数之后，还会递归调用patch处理，此时patch处理的不是组件而是element（`div`），此时并没有render这个函数，所以报错。后续针对`render`要区分`element`和`component`

**路径优化：**

在package.json中配置esm和cjs的入口

~~~json
"main": "lib/mini-vue.cjs.js",
"moudle": "lib/mini-vue.esm.js"
~~~

~~~js
import pkg from './package.json'

  output: [
    // 1.cjs -> comonjs
    // 2.esm -> es6模块规范（标准）
    {
      format: "cjs",
      file: "pkg.main",
    },
    {
      format: "es",
      file: "pkg.moudle",
    },
  ], 
~~~

## 初始化element主流程

当我们`createApp(app).mount(rootContainer)`后，会将app变成vnode，并调用其中的render函数，render函数在处理render时，执行`setupRenderEffect`返回的值还是vnode会再调用patch函数，但是**此时的vnode不是component而是element**，这里要进行区分。

~~~js
  render() {
    return h("div", {
      id: "root",
      class: ["red", "hard"],
    },
      // "hi, mini-vue"  children是简单的string类型
      [h("p", {class: "red"}, "hi"), h("p", {class: "blue"}, "mini-vue")]
    )
  },
~~~

### h函数

h函数同样是返回一个vnode，参数也是type、porps和children

~~~ts
 const h = function(type, props, children) {
   return createVNode(type, props, children)
 }
~~~

### 修改patch中处理element

+ 从`vnode.type`区分到底是element还是component

  + string类型 => element，object => component

+ processElement中调用mountElement

  + `document.createElement(vnode.type)`创建一个el

  + `const {children, props} = vnode`解构一下vnode

  + 如果children是string，直接`el.textContent = children`，如果children是数组，还需要递归调用patch，注意此时patch的container参数是当前的el

  + 遍历props，利用`el.setArrtibute(key, value)`赋予属性
+ `container.append(el)`最后把当前el添加到container容器中（这里container是app组件）

    

~~~ts
function patch(vnode, container) {
  // 判断vnode是element还是component
  if (typeof vnode.type === "string") {
    // 处理element（vnode.type = div）
    processElement(vnode, container);
  } else if (isObject(vnode.type)) {
    // 处理组件
    processComponent(vnode, container);
  }
}

function processElement(vnode: any, container: any) {
  mountElement(vnode, container)
}

function mountElement(vnode: any, container: any) {
  // 创建一个element
  const el = document.createElement(vnode.type)

  // string array children是render函数返回的第三个参数
  const {children} = vnode;
  if (typeof children === 'string') {
    el.textContent = children;
  } else if (Array.isArray(children)) {
    mountChildren(vnode, el)
  }

  // props
  const {props} = vnode;
  for (const key in props) {
    const val = props[key];
    el.setAttribute(key, val)
  }

  container.append(el)
}

function mountChildren(vnode: any, container: any) {
      // array里每一个都是虚拟节点
      vnode.children.forEach((v) => {
        patch(v, container)
      })
}
~~~

## 实现组件代理对象

~~~js
export const App = {
  render() {
    return h("div", {
      id: "root",
      class: ["red", "hard"],
    },
      // 在render中使用setup的数据
      "Hi, " + this.msg
    )
  },
  setup() {
    return {
      msg: 'mini-vue'
    }
  }
}
~~~

接下来要在render函数中**通过this访问setup中的msg**：在执行render函数时，将this绑定到setup函数返回的对象上(`setupState`)。

除此之外，我们没有再setup()中定义`$el`，但是vue3提供了`this.$el`用于访问组件实例管理的DOM根节点。

`$el`：直到组件挂载完成之前都是`undefined`

+ 对于单一根元素的组件，`$el`指向根元素
+ 对于以文本节点为根的组件，`$el` 将会指向该文本节点。
+ 对于以多个元素为根的组件，`$el` 将是一个仅作占位符的 DOM 节点，Vue 使用它来跟踪组件在 DOM 中的位置 (文本节点或 SSR 激活模式下的注释节点)。

**解决方法：**

这里用到了代理对象`Proxy`，我们需要通过this访问到`setupState`中的data以及`$el`、`$data`等相关属性。

+ 在组件初始化时创建代理对象
+ 在调用render函数时，将proxy绑定到render函数的this上



首先在mountComponent中处理setup时，在函数setupStatefulComponent中，我们拿到了setup函数返回的对象。同时，生成组件实例的代理对象，这里的组件实例就是app处理后的虚拟节点。

在Proxy中的handler对象中的get函数里，针对要访问的key进行返回值。因为我们将handler函数封装，所以要传入一个instance。

~~~ts
// component.ts

function setupStatefulComponent(instance: any) {
  // 先拿setup的返回值
  const Component = instance.type;

  instance.proxy = new Proxy(
    {_: instance}, 
    PublicInstanceProxyHandlers
  )

  const { setup } = Component;

  if (setup) {
    // setup可以返回obj或者function
    const setupResult = setup();
    handleSetupResult(instance, setupResult);
  }
}
~~~

单独封装代理对象的handler对象。利用map对象保存\$el,$data等属性，写成函数形式。

+ 如果是setup函数中的值，返回instance.setupState[key]

+ 如果是`$el`等属性，返回instance.vnode.el，这里instance是组件实例（具有vnode，type，setupState属性）

~~~ts
// 利用map对象保存$el,$data等属性
const publicPropertiesMap = {
  // 写成函数形式
  $el: (i) => i.vnode.el
}


export const PublicInstanceProxyHandlers = {
  get({_: instance}, key) {
    // setupState
    const { setupState } = instance;
    if (key in setupState) {
      return setupState[key];
    }

    const publicGetter = publicPropertiesMap[key]
    if (publicGetter) {
      return publicGetter(instance)
    }
  }
}
~~~



前面提到访问`$el`，通过`return instance.vnode.el`实现的，所以在创建component实例时，要初始化一个el值。

~~~ts
// vnode.ts

export function createVNode(type, props?, children?) { // ?表示可选参数
  const vnode = {
    type,
    props,
    children,
    el: null,
  };

  return vnode
}
~~~

接下来要考虑什么时候给vnode.el赋值，我们的`el`是组件的根节点，他不是component而是elment，所以是在mountElement中获取的。注意这里的vnode是app的vnode，我们将后续的`vnode`用`initialVnode`代替，使得代码结构更清晰。

~~~ts
function mountElement(vnode: any, container: any) {
  // 创建一个element,保存到vnode中
  const el = (vnode.el = document.createElement(vnode.type))

  // string array children是render函数返回的第三个参数
  const {children} = vnode;
  if (typeof children === 'string') {
    el.textContent = children;
  } else if (Array.isArray(children)) {
    mountChildren(vnode, el)
  }

  // props
  const {props} = vnode;
  for (const key in props) {
    const val = props[key];
    el.setAttribute(key, val)
  }

  container.append(el)
}
~~~



当我们执行render App时，执行到mountComponent时，需要创建组件实例，处理setup，继续处理render。此时执行render函数，再执行h函数得到`subTree`（这是新的虚拟节点），这个时候再对subTree进行patch，然后再执行`mountElement`，在这个函数中我们给subTree虚拟节点的el赋予正确的el（这里是`div`），执行完subTree的patch后，给我们的initialVnode.el也就是app的vnode.el赋予subTree的el。`initialVnode.el = subTree.el`

我们在render函数中利用`this.XXX`访问相关属性，所以执行render函数时，使用`call`绑定我们的额代理对象：`const subTree = instance.render.call(proxy)`

~~~ts
function setupRenderEffect(instance: any, initialVnode: any, container: any) {
  const { proxy } = instance;
  
  // 执行render函数
  const subTree = instance.render.call(proxy);
  // 由于执行render后返回依然是一个vnode对象，继续递归调用patch处理
  patch(subTree, container);
  // patch对h函数返回的vnode进行处理（这里就是subTree）
  // 在执行mountElement后，subTree.el已经赋好值了，这个时候再把值给vnode.el
  initialVnode.el = subTree.el
}
~~~



至此实现了组件化代理对象

测试的时候，我们再app.js中，先执行`window.self = null`，在render函数中在给他赋予当前render函数中的this：`window.self = this`，我们希望这个this是我们组件实例的代理对象`proxy`。

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20221206225652014.png" alt="image-20221206225652014" style="zoom:43%;" />

## 实现shapeFlags

 之前判断当前vnode是element还是component类型，或者判断children是string还是array，都采用`if (typeof vnode.type === "string") `判断。

使用**位运算**判断，更能提升运算销量。



创建一个ShapeFlags枚举类型，用二进制数反映各种类型

~~~ts
export const enum ShapeFlags {
  ELEMENT = 1, // 0001
  STATEFUL_COMPONENT = 1 << 1, // 二进制左移一位，0010
  TEXT_CHILDREN = 1 << 2, // 0100
  ARRAY_CHILDREN = 1 << 3, // 1000
    
// 位运算
// 0000
// 0001 -> element
// 0010 -> stateful_component
// 0100 -> text_children
// 1000 -> array_children

// | (两位都为0，才为0)
// & (两位都为1，才为1)

// 修改用或运算，查找用与运算
~~~

举例：

+ 当前节点是`element`，它地shapeFlags是`0001`，我们通过`&`判断他到底是不是`stateful_component`，`0001 & 0010`结果为`0000`,肯定是false
+ 当前节点的shapeFlag是`0001`，但是它的children类型是`array_children`，通过`|`运算，`0001 | 1000`，结果是`1001`，表示两种状态。

我们在vnode中，也要新增shapeFlags属性，并根据vnode.type和children的类型，修改shapeFlags的值。

~~~ts
// vnode.ts

import { ShapeFlags } from "../shared/ShapeFlags";

export function createVNode(type, props?, children?) {
  // ?表示可选参数
  const vnode = {
    type,
    props,
    children,
    shapeFlag: getShapeFlag(type),
    el: null,
  };

  // children
  if (typeof children === "string") {
    vnode.shapeFlag |= ShapeFlags.TEXT_CHILDREN;
  } else if (Array.isArray(children)) {
    vnode.shapeFlag |= ShapeFlags.ARRAY_CHILDREN;
  }

  return vnode;
}

// 之前都采用if (typeof vnode.type === "string") 判断类型
function getShapeFlag(type) {
  return typeof type === "string"
    ? ShapeFlags.ELEMENT
    : ShapeFlags.STATEFUL_COMPONENT;
}
~~~

在render时判断类型就可以采用与运算

~~~ts
function patch(vnode, container) {
  const { shapeFlag } = vnode;
  // 判断vnode是element还是component
  if (shapeFlag & ShapeFlags.ELEMENT) {
    // 处理element（vnode.type = div）
    processElement(vnode, container);
  } else if (shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {
    // 处理组件
    processComponent(vnode, container);
  }
}
~~~

