# 模板编译

之前在编写DOM时，都采用`h`函数来生成虚拟节点再转化为真实DOM节点。但是在实际中，都是通过编写`template`来生成DOM。

Vue3的模板编译思路：

+ 先将`template`转化为`AST`语法树
+ 根据`AST`语法树拼接`render`函数

AST抽象语法其实就是根据特定的标记对语法所生成的一个**对象**，这一点和虚拟DOM的概念很相似。

因为我们的重点是要讲`template`中的DOM结构生成`render`函数，所以对语法层面的编译不会过多的进行研究。

我们最终的目的是将：

```html
<div>hi,{{ message }}</div>
```

这个模版编译生成为`render`函数。

我们的模板需要处理的有三部分：

+ 插值表达式：`{{message}}`
+ 文本节点：`hi,`
+ 元素节点

## 实现解析插值功能

处理`{{message}}`这个插值表达式，核心问题是将`message`先取出来。

先写单元测试

~~~ts
// parse.spec.ts

describe("Parse", () => {
  // 插值功能
  describe("interpolation", () => {
    test("simple interpolation", () => {
      const ast = baseParse("{{message}}");
      // ast是整棵树的root
      expect(ast.children[0]).toStrictEqual({
        type: "interpolation",
        content: {
          type: "simple_expression",
          content: "message",
        },
      });
    });
  });
});
~~~

在这一小节，先实现将`{{message}}`转化为下面的对象结构：

~~~js
 {
   children: [
     {
       // INTERPOLATION代表插值类型
       type: "interpolation",
       content: {
         // 简单表达式
         type: "simple_expression",
         // 内容
         content: "message",
       }
     }
   ]
 }
~~~



重新创建文件夹`compile-core`处理模板编译。

在`parse.ts`中，导出`baseParse`函数，用于处理插值类型。

~~~ts
// content为{{ message }}
export function baseParse(content: string) {
  const context = createParserContext(content);
  return createRoot(parseChildren(context));
}
~~~

其中涉及到三个函数：`createParserContext`、`createRoot`、`parseChildren`

`createParserContext`用于生成一个执行对象，包裹`content`

~~~ts
function createParserContext(content: string): any {
  return {
    sorce: content,
  };
}
~~~

`parseChildren`用于解析字符串，并当做子集收集。

~~~ts
function parseChildren(context) {
  const nodes: any = [];
  let node: any
  if (context.sorce.startsWith("{{")) {
    node = parseInterpolation(context);
  }
  nodes.push(node);
  return nodes;
}
~~~

`parseInterpolation`处理插值类型，将`{{ message }}`解析为`message`

~~~ts
function parseInterpolation(context) {
  // 从传入的content：{{message}} 中拿到message
  const openDelimiter = "{{"
  const closeDelimiter = "}}"
  const closeIndedx = context.sorce.indexOf(closeDelimiter, openDelimiter.length);
  const rawContent = context.sorce.slice(openDelimiter.length, closeIndedx);
  const content = rawContent.trim()
  context.sorce = context.sorce.slice(closeIndedx + closeDelimiter.length)
  console.log(context.sorce);
  console.log(content);

  return {
    type: NodeTypes.INTERPOLATION,
    content: {
      type: NodeTypes.SIMPLE_EXPRESSION,
      content: content,
    }
  }
}
~~~
各个类型的标识是由枚举来进行取值：

```ts
// as

export const enum NodeTypes {
  INTERPOLATION,
  SIMPLE_EXPRESSION
}
```

> `String.prototype.trim()`从字符串两端清楚空格，返回一个新的字符串，而不修改原始字符串。

最后使用`createRoot`返回根对象：

~~~ts
function createRoot(children) {
  return {
    children,
  };
}
~~~

